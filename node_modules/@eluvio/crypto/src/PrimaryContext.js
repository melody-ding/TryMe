import Utils from './Utils.js'
import ScratchBuffer from './ScratchBuffer.js'

export default class PrimaryContext {
  /*
   * wasm
   * publicKey [Uint8Array PRIMARY_PK_KEY_SIZE]
   * secretKey [Uint8Array SECRET_KEY_SIZE] - Optional (needed for DecryptPrimary)
   * symmetricKey [Uint8Array AES_KEY_SIZE]
   * iv [Uint8Array IV_SIZE]
   */
  constructor(wasm, publicKey, secretKey, symmetricKey, iv) {
    const u = new Utils(wasm)
    const seed = Utils.randomBytes(wasm._EMS_SEED_SIZE_())
    const seedBuf = u.arrayToSmartBuf(seed)

    this.wasm = wasm
    this.utils = u
    /*
     * cryptoContext *NewCryptoContext(const char *seedData, int seedDataLen);
     */
    this.context = wasm._NewCryptoContext(seedBuf.ptr, seedBuf.len)
    this.iv = iv
    this.nextBlockIV = new Uint8Array(iv)
    this.pk = publicKey
    this.pkBuf = u.arrayToBuf(publicKey)
    this.scratchBuf = new ScratchBuffer(wasm)
    this.sk = secretKey
    this.skBuf = u.arrayToBuf(secretKey)
    this.symKey = symmetricKey
    this.symKeyBuf = u.arrayToBuf(symmetricKey)
  }

  clearBuf() {
    this.scratchBuf.clear()
  }

  free() {
    if (!this.context) return

    const w = this.wasm

    w._FreeCryptoContext(this.context)
    w._free(this.pkBuf.ptr)
    this.scratchBuf.free()
    w._free(this.symKeyBuf.ptr)

    this.context = null
    this.iv = null
    this.nextBlockIV = null
    this.pk = null
    this.pkBuf = null
    this.scratchBuf = null
    this.sk = null
    this.skBuf = null
    this.symKey = null
    this.symKeyBuf = null

    this.wasm = null
    this.utils = null
  }

  generateNextBlockIV() {
    for (let i = this.nextBlockIV.length - 1; ; i--) {
      if (this.nextBlockIV[i]++ !== 255) break
    }
    return new Uint8Array(this.nextBlockIV)
  }
}
