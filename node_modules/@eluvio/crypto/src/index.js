import Assets from './Assets.js'
import TargetDecryptionContext from './TargetDecryptionContext.js'
import PrimaryContext from './PrimaryContext.js'
import Utils from './Utils.js'
import ElvCryptoWasm from './ElvCryptoWasm.js'

import through from 'through2'
import ScratchBuffer from './ScratchBuffer.js'

/*
 * Usage:
 *   new ElvCrypto().init().then((elvc) => {
 *     console.log('Ready to go!');
 *     elvc.doStuff();
 *   });
 *
 * IMPORTANT:
 * - All data - i.e. not parameters like keys but the actual data to
 *   encrypt and decrypt - returned by API functions is only valid for the
 *   currenct cycle of the event loop, for efficiency purposes. Copy any data
 *   you need to persist. Moreover, a context object should not be used
 *   to call API functions again if the data is still needed, because the data
 *   is stored in a temporary buffer in the context.
 * - Both Uint8Array and Node.js Buffer (implements Uint8Array interface),
 *   are supported as data parameters. ArrayBuffer should work as well for
 *   data, but not crypto key parameters, for the time being.
 */
export default class ElvCrypto {
  constructor() {
    this.initResolve = null
    this.utils = null
    this.wasm = null
  }

  init() {
    const self = this
    const onWasmLoad = wasm => {
      self.wasm = wasm
      self.utils = new Utils(wasm)
      self.AES_KEY_SIZE = wasm._EMS_AES_KEY_SIZE_()
      self.CRYPTO_TYPE_TARGET = wasm._EMS_CRYPTO_TYPE_TARGET_()
      self.CRYPTO_TYPE_PRIMARY = wasm._EMS_CRYPTO_TYPE_PRIMARY_()
      self.TARGET_BLOCK_KEY_SIZE = wasm._EMS_TARGET_BLOCK_KEY_SIZE_()
      self.TARGET_PK_KEY_SIZE = wasm._EMS_TARGET_PK_KEY_SIZE_()
      self.ECIES_PK_KEY_SIZE = wasm._EMS_ECIES_PK_KEY_SIZE_()
      self.ECIES_SK_KEY_SIZE = wasm._EMS_ECIES_SK_KEY_SIZE_()
      self.IV_SIZE = wasm._EMS_IV_SIZE_()
      self.PRIMARY_BLOCK_KEY_SIZE = wasm._EMS_PRIMARY_BLOCK_KEY_SIZE_()
      self.PRIMARY_PK_KEY_SIZE = wasm._EMS_PRIMARY_PK_KEY_SIZE_()
      self.RE_ENCRYPTION_KEY_SIZE = wasm._EMS_RE_ENCRYPTION_KEY_SIZE_()
      self.SECRET_KEY_SIZE = wasm._EMS_SECRET_KEY_SIZE_()
      self.SEED_SIZE = wasm._EMS_SEED_SIZE_()
      self.TAG_SIZE = wasm._EMS_TAG_SIZE_()
      self.ELV_E_INCOMPLETE_BLOCK = -2
      if (self.initResolve) self.initResolve(self)
    }

    const b64 = Assets['ElvCrypto.wasm']
    ElvCryptoWasm({
      // Direct the Emscripten bootstrap code to fetch a data URI
      locateFile(path) {
        return path.endsWith('.wasm')
          ? 'data:application/octet-stream;base64,' + b64
          : path
      },
      // For Node.js Emscripten does not fetch so we convert string to buffer
      readBinary(filename) {
        return Buffer.from(b64, 'base64')
      }
    }).then(onWasmLoad)

    return new Promise(resolve => {
      if (self.wasm) {
        resolve(self)
      } else {
        self.initResolve = resolve
      }
    })
  }

  calcEncByteCount(clrBytes) {
    return this.wasm._CalcEncByteCount(clrBytes)
  }

  calcEncByteCountH(cryptoType, clrBytes) {
    return this.wasm._CalcEncByteCountH(cryptoType, clrBytes)
  }

  calcEncByteCountFromTargetH(targetBytes) {
    return this.wasm._CalcEncByteCountFromTargetH(targetBytes)
  }

  calcTargetByteCountH(primaryBytes) {
    return this.wasm._CalcTargetByteCountH(primaryBytes)
  }

  calcEncECIESByteCount(byteLenIn) {
    return this.wasm._CalcEncECIESByteCount(byteLenIn)
  }

  /*
   * Performs ECIES standard encryption of input data using the provided
   * public key.
   *
   * data [Uint8Array]
   * publicKey [Uint8Array ECIES_PK_KEY_SIZE] - An uncompressed, byte
   *   serialized secp256k1 key - the same curve type used by Ethereum.
   *
   * Returns the encrypted bytes, the 65 byte encrypted ephemeral key used for
   *   encryption and also required for decryption, and the 16 byte HMAC tag
   *   to verify the data integrity when decrypted:
   *   {
   *     data: [Uint8Array],
   *     ephemeralKey: [Uint8Array ECIES_PK_KEY_SIZE],
   *     tag: [Uint8Array TAG_SIZE]
   *   }
   */
  encryptECIES(data, publicKey) {
    if (publicKey.length !== this.ECIES_PK_KEY_SIZE) {
      throw new Error(`encryptECIES() failed: Expected publicKey length
        ${this.ECIES_PK_KEY_SIZE}, not ${publicKey.length}`)
    }

    const w = this.wasm
    const u = this.utils

    const seed = Utils.randomBytes(this.SEED_SIZE)
    const dataBuf = u.arrayToSmartBuf(data)
    const pkBuf = u.arrayToSmartBuf(publicKey)
    const seedBuf = u.arrayToSmartBuf(seed)

    const outSize = this.calcEncECIESByteCount(dataBuf.len)
    const out = u.smartMalloc(outSize)
    const ekOut = u.smartMalloc(this.ECIES_PK_KEY_SIZE)
    const tagOut = u.smartMalloc(this.TAG_SIZE)

    /*
     * int EncryptECIES(const char *seedData, int seedDataLen,
     *                  char *pubKeyBytesIn,
     *                  char *clearBytesIn, int clrBytesLen,
     *                  char *encBytesOut, int encBytesLen,
     *                  char *ephKeyBytesOut,
     *                  char *tagBytesOut);
     */
    const error = w._EncryptECIES(
      seedBuf.ptr,
      seedBuf.len,
      pkBuf.ptr,
      dataBuf.ptr,
      dataBuf.len,
      out,
      outSize,
      ekOut,
      tagOut
    )
    if (error !== 0) {
      throw new Error(`_EncryptECIES failed with error code ${error}`)
    }
    return {
      data: new Uint8Array(w.HEAPU8.buffer, out, outSize),
      ephemeralKey: new Uint8Array(
        w.HEAPU8.buffer,
        ekOut,
        this.ECIES_PK_KEY_SIZE
      ).slice(0),
      tag: new Uint8Array(w.HEAPU8.buffer, tagOut, this.TAG_SIZE).slice(0)
    }
  }

  /*
   * Performs ECIES standard decryption of data encrypted with a secp256k1
   * public key.
   *
   * data [Uint8Array]
   * secretKey [Uint8Array ECIES_SK_KEY_SIZE] - The private key corresponding
   *   to the public key used for encryption.
   * ephemeralKey [Uint8Array ECIES_PK_KEY_SIZE] - Generated by encryption
   * tag [Uint8Array TAG_SIZE] - Generated by encryption
   *
   * Returns the decrypted bytes as an Uint8Array
   */
  decryptECIES(data, secretKey, ephemeralKey, tag) {
    if (secretKey.length !== this.ECIES_SK_KEY_SIZE) {
      throw new Error(`decryptECIES() failed: Expected secretKey length
        ${this.ECIES_SK_KEY_SIZE}, not ${secretKey.length}`)
    }
    if (ephemeralKey.length !== this.ECIES_PK_KEY_SIZE) {
      throw new Error(`decryptECIES() failed: Expected ephemeralKey length
        ${this.ECIES_PK_KEY_SIZE}, not ${ephemeralKey.length}`)
    }
    if (tag.length !== this.TAG_SIZE) {
      throw new Error(`decryptECIES() failed: Expected tag length
        ${this.TAG_SIZE}, not ${tag.length}`)
    }

    const w = this.wasm
    const u = this.utils

    const dataBuf = u.arrayToSmartBuf(data)
    const skBuf = u.arrayToSmartBuf(secretKey)
    const ekBuf = u.arrayToSmartBuf(ephemeralKey)
    const tagBuf = u.arrayToSmartBuf(tag)

    const outSize = dataBuf.len
    const out = u.smartMalloc(outSize)

    /*
     * int DecryptECIES(char *ephKeyBytesIn,
     *                  char *encBytesIn, int encBytesLen,
     *                  char *tagBytesIn,
     *                  char *privKeyBytesIn,
     *                  char *clrBytesOut, int clrBytesLen);
     */
    const size = w._DecryptECIES(
      ekBuf.ptr,
      dataBuf.ptr,
      dataBuf.len,
      tagBuf.ptr,
      skBuf.ptr,
      out,
      outSize
    )
    if (size === -1) throw new Error('_DecryptECIES failed')
    return new Uint8Array(w.HEAPU8.buffer, out, size)
  }

  /*
   * Generates a "target" private / public key pair for use in content
   * re-encryption. Target keys are generally used to receive re-encrypted
   * data and not for direct encryption.
   *
   * Returns a 48 byte private key and uncompressed 193 byte public key that
   * follows the convention of 0x04 as the first byte:
   *   {
   *     secretKey: [Uint8Array SECRET_KEY_SIZE],
   *     publicKey: [Uint8Array TARGET_PK_KEY_SIZE]
   *   }
   */
  generateTargetKeys() {
    const w = this.wasm
    const u = this.utils

    const seed = Utils.randomBytes(this.SEED_SIZE)
    const seedBuf = u.arrayToSmartBuf(seed)
    const skOut = u.smartMalloc(this.SECRET_KEY_SIZE)
    const pkOut = u.smartMalloc(this.TARGET_PK_KEY_SIZE)

    /*
     * int GenerateTargetKeys(const char *seedData, int seedDataLen,
     *                        char *skBytesOut,
     *                        char *pkBytesOut)
     */
    const error = w._GenerateTargetKeys(seedBuf.ptr, seedBuf.len, skOut, pkOut)
    if (error !== 0) {
      throw new Error(`_GenerateTargetKeys failed with error code ${error}`)
    }
    return {
      secretKey: new Uint8Array(
        w.HEAPU8.buffer,
        skOut,
        this.SECRET_KEY_SIZE
      ).slice(0),
      publicKey: new Uint8Array(
        w.HEAPU8.buffer,
        pkOut,
        this.TARGET_PK_KEY_SIZE
      ).slice(0)
    }
  }

  /*
   * Generates a "primary" private / public key pair for use in content
   * encryption. Primary encryption is generally the encryption performed by the
   * owner or publisher of the content.
   *
   * Returns a 48 byte private key and 97 byte public key that follows the
   * convention of 0x04 as the first byte:
   *   {
   *     secretKey: [Uint8Array SECRET_KEY_SIZE],
   *     publicKey: [Uint8Array PRIMARY_PK_KEY_SIZE]
   *   }
   */
  generatePrimaryKeys() {
    const w = this.wasm
    const u = this.utils

    const seed = Utils.randomBytes(this.SEED_SIZE)
    const seedBuf = u.arrayToSmartBuf(seed)
    const skOut = u.smartMalloc(this.SECRET_KEY_SIZE)
    const pkOut = u.smartMalloc(this.PRIMARY_PK_KEY_SIZE)

    /*
     * int GeneratePrimaryKeys(const char *seedData, int seedDataLen,
     *                         char *skBytesOut,
     *                         char *pkBytesOut)
     */
    const error = w._GeneratePrimaryKeys(seedBuf.ptr, seedBuf.len, skOut, pkOut)
    if (error !== 0) {
      throw new Error(`_GeneratePrimaryKeys failed with error code ${error}`)
    }
    return {
      secretKey: new Uint8Array(
        w.HEAPU8.buffer,
        skOut,
        this.SECRET_KEY_SIZE
      ).slice(0),
      publicKey: new Uint8Array(
        w.HEAPU8.buffer,
        pkOut,
        this.PRIMARY_PK_KEY_SIZE
      ).slice(0)
    }
  }

  /*
   * Creates a key that can be used to re-encrypt data from 'primary'
   * encryption to 'target' encryption. It is then in a form where it can be
   * decrypted with the private target key of the intended recipient.
   *
   * primarySK [Uint8Array SECRET_KEY_SIZE]: The primary private key used to
   *   encrypt the data
   * targetPK [Uint8Array TARGET_PK_KEY_SIZE]: The target public key of
   *   the target recipient of the re-encrypted data.
   *
   * Returns a 193 key: [Uint8Array RE_ENCRYPTION_KEY_SIZE]
   */
  generateReEncryptionKey(primarySK, targetPK) {
    if (primarySK.length !== this.SECRET_KEY_SIZE) {
      throw new Error(`generateReEncryptionKey() failed: Expected primarySK
        length ${this.SECRET_KEY_SIZE}, not ${primarySK.length}`)
    }
    if (targetPK.length !== this.TARGET_PK_KEY_SIZE) {
      throw new Error(`generateReEncryptionKey() failed: Expected targetPK
        length ${this.TARGET_PK_KEY_SIZE}, not ${targetPK.length}`)
    }

    const w = this.wasm
    const u = this.utils

    const skBuf = u.arrayToSmartBuf(primarySK)
    const pkBuf = u.arrayToSmartBuf(targetPK)
    const out = u.smartMalloc(this.RE_ENCRYPTION_KEY_SIZE)

    /*
     * int GenerateReEncryptionKey(char *skPrimaryBytesIn,
     *                             char *pkTargetBytesIn,
     *                             char *reEncKeyBytesOut)
     */
    const error = w._GenerateReEncryptionKey(skBuf.ptr, pkBuf.ptr, out)
    if (error !== 0) {
      throw new Error(
        `_GenerateReEncryptionKey failed with error code ${error}`
      )
    }
    return new Uint8Array(
      w.HEAPU8.buffer,
      out,
      this.RE_ENCRYPTION_KEY_SIZE
    ).slice(0)
  }

  /*
   * Generates a symmetric key and an initialization vector (IV) for use
   * with content encryption.
   *
   * Returns a 16 byte key (AES-128) and 12 byte IV:
   *   {
   *     key: [Uint8Array AES_KEY_SIZE],
   *     iv: [Uint8Array IV_SIZE]
   *   }
   */
  generateSymmetricKey() {
    const w = this.wasm
    const u = this.utils

    const seed = Utils.randomBytes(this.SEED_SIZE)
    const seedBuf = u.arrayToSmartBuf(seed)
    const keyOut = u.smartMalloc(this.AES_KEY_SIZE)
    const ivOut = u.smartMalloc(this.IV_SIZE)

    /*
     * int GenerateSymmetricKeys(const char *seedData, int seedDataLen,
     *                           char *keyBytesOut,
     *                           char *ivBytesOut)
     */
    const error = w._GenerateSymmetricKeys(
      seedBuf.ptr,
      seedBuf.len,
      keyOut,
      ivOut
    )
    if (error !== 0) {
      throw new Error(`_GenerateSymmetricKeys failed with error code ${error}`)
    }
    return {
      key: new Uint8Array(w.HEAPU8.buffer, keyOut, this.AES_KEY_SIZE).slice(0),
      iv: new Uint8Array(w.HEAPU8.buffer, ivOut, this.IV_SIZE).slice(0)
    }
  }

  /*
   * Creates a context used for block-based primary encryption through
   * EncryptPrimary. Free the context when done.
   *
   * publicKey [Uint8Array PRIMARY_PK_KEY_SIZE]
   * secretKey [Uint8Array SECRET_KEY_SIZE] - Optional (needed for DecryptPrimary)
   * symmetricKey [Uint8Array AES_KEY_SIZE]
   *
   * returns PrimaryContext
   */
  newPrimaryContext(publicKey, secretKey, symmetricKey) {
    if (publicKey && publicKey.length !== this.PRIMARY_PK_KEY_SIZE) {
      throw new Error(`newPrimaryContext() failed: Expected publicKey
        length ${this.PRIMARY_PK_KEY_SIZE}, not ${publicKey.length}`)
    }
    if (secretKey && secretKey.length !== this.SECRET_KEY_SIZE) {
      throw new Error(`newPrimaryContext() failed: Expected secretKey
        length ${this.SECRET_KEY_SIZE}, not ${secretKey.length}`)
    }
    if (symmetricKey.length !== this.AES_KEY_SIZE) {
      throw new Error(`newPrimaryContext() failed: Expected
        symmetricKey length ${this.AES_KEY_SIZE}, not ${symmetricKey.length}`)
    }

    // Generate a "base" IV for this context
    const tempKey = this.generateSymmetricKey()

    return new PrimaryContext(
      this.wasm,
      publicKey,
      secretKey,
      symmetricKey,
      tempKey.iv
    )
  }

  /*
   * Performs one 'block' of primary encryption. Each block has both
   * performance and data size overhead so a fairly large block size is
   * intended and recommended. We currently use 1MB as a default clear-text
   * block size. The initialization vector (IV) must be unique for each block
   * so the context provides a helper function that can be used to generate a
   * base IV that can then be incremented to create unique values.
   *
   * PrimaryContext
   * data [Uint8Array]
   * iv [Uint8Array IV_SIZE (12 bytes)]
   *
   * Returns: {
   *   blockKey [Uint8Array PRIMARY_BLOCK_KEY_SIZE (97 bytes)],
   *   data [Uint8Array],
   *   tag [Uint8Array TAG_SIZE (16 bytes)],
   * }
   */
  encryptPrimary(context, data, iv) {
    if (iv.length !== this.IV_SIZE) {
      throw new Error(`encryptPrimary() failed: Expected iv
        length ${this.IV_SIZE}, not ${iv.length}`)
    }
    if (context.scratchBuf.len !== 0) {
      throw new Error(`encryptPrimary() failed: Scratch buffer is not empty`)
    }

    const w = this.wasm
    const u = this.utils

    const ivBuf = u.arrayToSmartBuf(iv)
    const dataBuf = u.arrayToSmartBuf(data)
    const outSize = this.calcEncByteCount(dataBuf.len)
    context.scratchBuf.ensureSize(outSize)
    const tagOut = u.smartMalloc(this.TAG_SIZE)
    const blockKeyOut = u.smartMalloc(this.PRIMARY_BLOCK_KEY_SIZE)

    /*
     * int EncryptPrimary(cryptoContext *cxt,
     *                    char *pkBytesIn,
     *                    char *symmKeyBytesIn,
     *                    char *blockIVBytesIn,
     *                    char *clearBytesIn, int bytesLenIn,
     *                    char *encBytesOut, int bytesLenOut,
     *                    char *tagBytesOut,
     *                    char *blkKeyBytesOut);
     */
    const error = w._EncryptPrimary(
      context.context,
      context.pkBuf.ptr,
      context.symKeyBuf.ptr,
      ivBuf.ptr,
      dataBuf.ptr,
      dataBuf.len,
      context.scratchBuf.ptr,
      outSize,
      tagOut,
      blockKeyOut
    )
    if (error !== 0) {
      throw new Error(`_EncryptPrimary failed with error code ${error}`)
    }
    return {
      blockKey: new Uint8Array(
        w.HEAPU8.buffer,
        blockKeyOut,
        this.PRIMARY_BLOCK_KEY_SIZE
      ).slice(0),
      data: new Uint8Array(w.HEAPU8.buffer, context.scratchBuf.ptr, outSize),
      tag: new Uint8Array(w.HEAPU8.buffer, tagOut, this.TAG_SIZE).slice(0)
    }
  }

  /*
   * Same as EncryptPrimary except the blockKey and tag are included in the
   * encrypted data output, and the iv is generated automatically using the
   * context method generateNextBlockIV.
   *
   * PrimaryContext
   * data [Uint8Array]
   *
   * Returns: data [Uint8Array]
   */
  encryptPrimaryH(context, data) {
    if (context.scratchBuf.len !== 0) {
      throw new Error(`encryptPrimaryH() failed: Scratch buffer is not empty`)
    }

    const w = this.wasm
    const u = this.utils

    const iv = context.generateNextBlockIV()
    const ivBuf = u.arrayToSmartBuf(iv)
    const dataBuf = u.arrayToSmartBuf(data)
    const outSize = this.calcEncByteCountH(
      this.CRYPTO_TYPE_PRIMARY,
      dataBuf.len
    )
    context.scratchBuf.ensureSize(outSize)

    /*
     * int EncryptPrimaryH(cryptoContext *cxt,
     *                     const char *pkBytesIn,
     *                     const char *symmKeyBytesIn,
     *                     const char *blockIVBytesIn,
     *                     const char *clearBytesIn, const size_t bytesLenIn,
     *                     char *encBytesOut);
     */
    const error = w._EncryptPrimaryH(
      context.context,
      context.pkBuf.ptr,
      context.symKeyBuf.ptr,
      ivBuf.ptr,
      dataBuf.ptr,
      dataBuf.len,
      context.scratchBuf.ptr
    )
    if (error !== 0) {
      throw new Error(`_EncryptPrimaryH failed with error code ${error}`)
    }
    return new Uint8Array(w.HEAPU8.buffer, context.scratchBuf.ptr, outSize)
  }

  /*
   * PrimaryContext
   * data [Uint8Array]
   * tag [Uint8Array TAG_SIZE (16 bytes)]
   * blockKey [Uint8Array PRIMARY_BLOCK_KEY_SIZE (97 bytes)]
   * iv [Uint8Array IV_SIZE (12 bytes)]
   * clearSize - length of decrypted data
   *
   * Returns decrypted data [Uint8Array]
   */
  decryptPrimary(context, data, tag, blockKey, iv, clearSize) {
    if (tag.length !== this.TAG_SIZE) {
      throw new Error(`decryptPrimary() failed: Expected tag
        length ${this.TAG_SIZE}, not ${tag.length}`)
    }
    if (blockKey.length !== this.PRIMARY_BLOCK_KEY_SIZE) {
      throw new Error(`decryptPrimary() failed: Expected blockKey
        length ${this.PRIMARY_BLOCK_KEY_SIZE}, not ${blockKey.length}`)
    }
    if (iv.length !== this.IV_SIZE) {
      throw new Error(`decryptPrimary() failed: Expected iv
        length ${this.IV_SIZE}, not ${iv.length}`)
    }
    if (context.scratchBuf.len !== 0) {
      throw new Error(`decryptPrimary() failed: Scratch buffer is not empty`)
    }

    const w = this.wasm
    const u = this.utils

    const dataBuf = u.arrayToSmartBuf(data)
    const bkBuf = u.arrayToSmartBuf(blockKey)
    const ivBuf = u.arrayToSmartBuf(iv)
    const tagBuf = u.arrayToSmartBuf(tag)
    context.scratchBuf.ensureSize(clearSize)

    /*
     * int DecryptPrimary(cryptoContext *cxt,
     *                    char *skBytesIn,
     *                    char *blkKeyBytesIn,
     *                    char *symmKeyBytesIn,
     *                    char *blockIVBytesIn,
     *                    char *tagBytesIn,
     *                    char *encBytesIn, int bytesLenIn,
     *                    char *clearBytesOut, int bytesLenOut);
     */
    const error = w._DecryptPrimary(
      context.context,
      context.skBuf.ptr,
      bkBuf.ptr,
      context.symKeyBuf.ptr,
      ivBuf.ptr,
      tagBuf.ptr,
      dataBuf.ptr,
      dataBuf.len,
      context.scratchBuf.ptr,
      clearSize
    )

    if (error !== 0) {
      throw new Error(`_DecryptPrimary failed with error code ${error}`)
    }
    return new Uint8Array(w.HEAPU8.buffer, context.scratchBuf.ptr, clearSize)
  }

  /*
   * Re-encrypt the block key and update the header. The encrypted data remains
   * the same.
   *
   * scratch - buffer for efficiency
   * reEncKey - the re-encryption key
   * data [Uint8Array]
   *
   * Returns [Uint8Array]
   */
  reEncryptH(scratch, reEncKey, data) {
    if (reEncKey.length !== this.RE_ENCRYPTION_KEY_SIZE) {
      throw new Error(`reEncryptBlockKey() failed: Expected reEncKey
        length ${this.RE_ENCRYPTION_KEY_SIZE}, not ${reEncKey.length}`)
    }

    const w = this.wasm
    const u = this.utils

    const rekBuf = u.arrayToSmartBuf(reEncKey)
    const dataBuf = u.arrayToSmartBuf(data)
    scratch.ensureSize(this.calcTargetByteCountH(dataBuf.len))
    const targetSizePtr = u.smartMalloc(4)

    /*
     * int ReEncryptH(const char *reEncKey, const char *encData,
     *                int encDataLen, char *targetBlock, int *targetBlockLen);
     */
    const error = w._ReEncryptH(
      rekBuf.ptr,
      dataBuf.ptr,
      dataBuf.len,
      scratch.ptr,
      targetSizePtr
    )
    if (error === this.ELV_E_INCOMPLETE_BLOCK) {
      throw new Error('ELV_E_INCOMPLETE_BLOCK')
    }
    if (error !== 0) {
      throw new Error(`_ReEncryptH failed with error code ${error}`)
    }
    const targetSize = w.getValue(targetSizePtr, 'i32')
    return new Uint8Array(w.HEAPU8.buffer, scratch.ptr, targetSize)
  }

  /*
   * Same as decryptPrimary/Target except the blockKey, iv, tag, and
   * clearSize are already included in the encrypted data input.
   *
   * type - CRYPTO_TYPE_TARGET or CRYPTO_TYPE_PRIMARY
   * PrimaryContext
   * data [Uint8Array]
   *
   * Returns decrypted data [Uint8Array]
   */
  decryptH(type, context, data) {
    if (type !== this.CRYPTO_TYPE_TARGET && type !== this.CRYPTO_TYPE_PRIMARY) {
      throw new Error(`decryptH() failed: Invalid type ${type}`)
    }
    if (context.scratchBuf.len !== 0) {
      throw new Error(`decryptH() failed: Scratch buffer is not empty`)
    }

    const w = this.wasm
    const u = this.utils

    const dataBuf = u.arrayToSmartBuf(data)
    context.scratchBuf.ensureSize(dataBuf.len) // decrypted data is always smaller
    const clearSizePtr = u.smartMalloc(4)

    /*
     * int DecryptH(int cryptoType, cryptoContext *cxt, const char *sk,
     *              const char *symKey, const char *encData, int encDataLen,
     *              char *clearData, int *clearDataLen);
     */
    const error = w._DecryptH(
      type,
      context.context,
      context.skBuf.ptr,
      context.symKeyBuf.ptr,
      dataBuf.ptr,
      dataBuf.len,
      context.scratchBuf.ptr,
      clearSizePtr
    )
    if (error === this.ELV_E_INCOMPLETE_BLOCK) {
      throw new Error('ELV_E_INCOMPLETE_BLOCK')
    }
    if (error !== 0) {
      throw new Error(`_DecryptH failed with error code ${error}`)
    }
    const clearSize = w.getValue(clearSizePtr, 'i32')
    return new Uint8Array(w.HEAPU8.buffer, context.scratchBuf.ptr, clearSize)
  }

  /*
   * Used to re-encrypt a block key using the provided re-encryption key (see
   * "GenerateReEncryptionKey"). The block key is transformed in a way such
   * that it can be used by the holder of the target private key to decrypt
   * the encrypted data in a block. The encrypted data itself is not
   * transformed so the process of re-encryption is very efficient since the
   * bulk of the data is not manipulated.
   *
   * reEncKey [Uint8Array RE_ENCRYPTION_KEY_SIZE]
   * blockKey [Uint8Array PRIMARY_BLOCK_KEY_SIZE]
   *
   * Returns the target block key: [Uint8Array TARGET_BLOCK_KEY_SIZE]
   */
  reEncryptBlockKey(reEncKey, blockKey) {
    if (reEncKey.length !== this.RE_ENCRYPTION_KEY_SIZE) {
      throw new Error(`reEncryptBlockKey() failed: Expected reEncKey
        length ${this.RE_ENCRYPTION_KEY_SIZE}, not ${reEncKey.length}`)
    }
    if (blockKey.length !== this.PRIMARY_BLOCK_KEY_SIZE) {
      throw new Error(`reEncryptBlockKey() failed: Expected blockKey
        length ${this.PRIMARY_BLOCK_KEY_SIZE}, not ${blockKey.length}`)
    }

    const w = this.wasm
    const u = this.utils

    const rekBuf = u.arrayToSmartBuf(reEncKey)
    const bkBuf = u.arrayToSmartBuf(blockKey)
    const out = u.smartMalloc(this.TARGET_BLOCK_KEY_SIZE)

    /*
     * int ReEncryptBlockKey(char *reEncKeyBytesIn,
     *                       char *blkKeyBytesIn,
     *                       char *tgtBlkKeyBytesOut);
     */
    const error = w._ReEncryptBlockKey(rekBuf.ptr, bkBuf.ptr, out)
    if (error !== 0) {
      throw new Error(`_ReEncryptBlockKey failed with error code ${error}`)
    }

    return new Uint8Array(
      w.HEAPU8.buffer,
      out,
      this.TARGET_BLOCK_KEY_SIZE
    ).slice(0)
  }

  /*
   * Creates a context used for block-based target decryption through
   * DecryptTarget. Free the context when done.
   *
   * secretKey [Uint8Array SECRET_KEY_SIZE]
   * symmetricKey [Uint8Array AES_KEY_SIZE]
   *
   * returns TargetDecryptionContext
   */
  newTargetDecryptionContext(secretKey, symmetricKey) {
    if (secretKey.length !== this.SECRET_KEY_SIZE) {
      throw new Error(`newTargetDecryptionContext() failed: Expected
        secretKey length ${this.SECRET_KEY_SIZE}, not ${secretKey.length}`)
    }
    if (symmetricKey.length !== this.AES_KEY_SIZE) {
      throw new Error(`newTargetDecryptionContext() failed: Expected
        symmetricKey length ${this.AES_KEY_SIZE}, not ${symmetricKey.length}`)
    }
    return new TargetDecryptionContext(this.wasm, secretKey, symmetricKey)
  }

  /*
   * Decrypt data that has been re-encrypted for a target target public key.
   * The initialization vector, tag and encrypted bytes from the original
   * encryption must be provided. The re-encrypted block key that corresponds
   * to the target target key must also be provided. It is assumed that all
   * of this data is stored together as a block since all of the data is
   * necessary and secure.
   *
   * TargetDecryptionContext
   * data [Uint8Array]
   * blockKey [Uint8Array TARGET_BLOCK_KEY_SIZE (576 bytes)]
   * iv [Uint8Array IV_SIZE (12 bytes)]
   * tag [Uint8Array TAG_SIZE (16 bytes)]
   * clearSize - length of decrypted data
   *
   * Returns decrypted data [Uint8Array]
   */
  decryptTarget(context, data, tag, blockKey, iv, clearSize) {
    if (tag.length !== this.TAG_SIZE) {
      throw new Error(`decryptTarget() failed: Expected tag
        length ${this.TAG_SIZE}, not ${tag.length}`)
    }
    if (blockKey.length !== this.TARGET_BLOCK_KEY_SIZE) {
      throw new Error(`decryptTarget() failed: Expected blockKey
        length ${this.TARGET_BLOCK_KEY_SIZE}, not ${blockKey.length}`)
    }
    if (iv.length !== this.IV_SIZE) {
      throw new Error(`decryptTarget() failed: Expected iv
        length ${this.IV_SIZE}, not ${iv.length}`)
    }
    if (context.scratchBuf.len !== 0) {
      throw new Error(`decryptTarget() failed: Scratch buffer is not empty`)
    }

    const w = this.wasm
    const u = this.utils

    const dataBuf = u.arrayToSmartBuf(data)
    const bkBuf = u.arrayToSmartBuf(blockKey)
    const ivBuf = u.arrayToSmartBuf(iv)
    const tagBuf = u.arrayToSmartBuf(tag)
    context.scratchBuf.ensureSize(clearSize)

    /*
     * int DecryptTarget(cryptoContext *cxt,
     *                     char *skTgtBytesIn,
     *                     char *tgtBlkKeyBytesIn,
     *                     char *symmKeyBytesIn,
     *                     char *blockIVBytesIn,
     *                     char *tagBytesIn,
     *                     char *encBytesIn, int bytesLenIn,
     *                     char *clearBytesOut, int bytesLenOut);
     */
    const error = w._DecryptTarget(
      context.context,
      context.skBuf.ptr,
      bkBuf.ptr,
      context.symKeyBuf.ptr,
      ivBuf.ptr,
      tagBuf.ptr,
      dataBuf.ptr,
      dataBuf.len,
      context.scratchBuf.ptr,
      clearSize
    )
    if (error !== 0) {
      throw new Error(`_DecryptTarget failed with error code ${error}`)
    }
    return new Uint8Array(w.HEAPU8.buffer, context.scratchBuf.ptr, clearSize)
  }

  createCipher(context) {
    const elvc = this
    return through(function(chunk, encoding, callback) {
      this.push(elvc.encryptPrimaryH(context, chunk))
      context.clearBuf()
      callback()
    })
  }

  createDecipher(type, context) {
    const elvc = this
    let buf = Buffer.alloc(0)
    return through(
      function(chunk, encoding, callback) {
        let index = 0
        buf = Buffer.concat([buf, chunk])
        while (index < buf.length) {
          try {
            context.clearBuf()
            let block = elvc.decryptH(type, context, buf.slice(index))
            this.push(block)
            index += elvc.calcEncByteCountH(type, block.length)
          } catch (e) {
            if (e.message === 'ELV_E_INCOMPLETE_BLOCK') {
              buf = buf.slice(index)
              callback()
              return
            } else {
              buf = Buffer.alloc(0)
              callback(e)
              return
            }
          }
        }
        buf = Buffer.alloc(0)
        callback()
      },
      function(callback) {
        if (buf.length > 0) {
          this.destroy(
            new Error(
              'Decipher stream ended before all data was decrypted. The source may be invalid.'
            )
          )
        }
        callback()
      }
    )
  }

  createRecipher(reEncKey) {
    const elvc = this
    const scratch = new ScratchBuffer(elvc.wasm)
    let buf = Buffer.alloc(0)
    let stream = through(
      function(chunk, encoding, callback) {
        let index = 0
        buf = Buffer.concat([buf, chunk])
        while (index < buf.length) {
          try {
            scratch.clear()
            let block = elvc.reEncryptH(scratch, reEncKey, buf.slice(index))
            this.push(block)
            index += elvc.calcEncByteCountFromTargetH(block.length)
          } catch (e) {
            if (e.message === 'ELV_E_INCOMPLETE_BLOCK') {
              buf = buf.slice(index)
              callback()
              return
            } else {
              buf = Buffer.alloc(0)
              callback(e)
              return
            }
          }
        }
        buf = Buffer.alloc(0)
        callback()
      },
      function(callback) {
        if (buf.length > 0) {
          this.destroy(
            new Error(
              'Recipher stream ended before all data was decrypted. The source may be invalid.'
            )
          )
        }
        callback()
      }
    )
    stream.on('finish', () => {
      scratch.free()
    })
    return stream
  }
}
