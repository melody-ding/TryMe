/* global window */

import crypto from 'crypto'

export default class Utils {
  constructor(wasm) {
    this.wasm = wasm
  }

  /*
   * Converts a byte array (Uint8Array) to hex string
   */
  static bytesToHex(bytes) {
    return bytes.reduce(
      (str, byte) => str + byte.toString(16).padStart(2, '0'),
      ''
    )
  }

  static bytesToBinary(bytes) {
    return bytes.reduce(
      (str, byte) => str + byte.toString(2).padStart(8, '0') + ' ',
      ''
    )
  }

  /*
   * Converts a hex string to a byte array (Uint8Array)
   */
  static hexToBytes(hex) {
    return new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)))
  }

  static randomBytes(size) {
    if (typeof window !== 'undefined' && window.crypto !== 'undefined') {
      let bytes = new Uint8Array(size)
      window.crypto.getRandomValues(bytes)
      return bytes
    } else {
      return crypto.randomBytes(size) // Buffer is a Uint8Array
    }
  }

  /*
   * Write TypedArray to memory to use in a WASM function call. Caller is
   * responsible for freeing the pointer.
   *
   * Returns {
   *   ptr: [for WASM],
   *   len: arr.length
   * }
   */
  arrayToBuf(arr) {
    const w = this.wasm
    const buf = {
      ptr: null,
      len: 0
    }
    if (!arr) return buf

    let typedArr = null
    if (
      arr instanceof Uint8Array ||
      (typeof Buffer !== 'undefined' && arr instanceof Buffer)
    ) {
      typedArr = arr
    } else if (
      arr instanceof ArrayBuffer ||
      arr.__proto__.toString().includes('ArrayBuffer')
    ) {
      typedArr = new Uint8Array(arr)
    } else {
      throw new Error(`arrayToBuf() failed: Expected Uint8Array, Buffer, or
        ArrayBuffer`)
    }
    buf.len = typedArr.length
    buf.ptr = w._malloc(typedArr.length)
    w.writeArrayToMemory(typedArr, buf.ptr)
    return buf
  }

  /*
   * Automatically free the pointer later on the event loop
   */
  arrayToSmartBuf(arr) {
    const w = this.wasm
    const buf = this.arrayToBuf(arr)
    if (buf.ptr) {
      setTimeout(() => {
        w._free(buf.ptr)
        buf.len = 0
        buf.ptr = null
      }, 0)
    }
    return buf
  }

  /*
   * Allocate a buffer to be automatically freed later on the event loop
   */
  smartMalloc(size) {
    const w = this.wasm
    const ptr = w._malloc(size)
    setTimeout(() => {
      w._free(ptr)
    }, 0)
    return ptr
  }
}
