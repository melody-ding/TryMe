/*
 * Note: Named webpack.config.babel.js to allow ES6 in this file (also need
 *       @babel/register from npm)
 *
 * Wasm packing example: https://gist.github.com/surma/b2705b6cca29357ebea1c9e6e15684cc
 *   We do things a bit differently but it is informative.
 *
 * TODO: Test different options for Node vs Web
 */

const path = require('path')
const nodeExternals = require('webpack-node-externals')

module.exports = env => {
  const libName = 'elv-crypto'
  const entry = {}
  entry[libName] = './src/index.js'

  const base = () => {
    return {
      context: path.resolve(__dirname, '.'),
      // devtool: 'source-map',
      entry: entry,
      // mode: 'development',
      mode: 'production',
      module: {
        exprContextCritical: false,
        rules: [
          // {
          //   loader: 'babel-loader',
          //   test: /\.js$/,
          //   exclude: /node_modules/,
          // }
        ]
      },
      output: {
        filename: '[name].bundle.js',
        library: libName,
        libraryTarget: 'umd',
        path: path.resolve(__dirname, 'dist'),
        umdNamedDefine: true
      }
    }
  }

  const web = base()
  // This is necessary due to the fact that emscripten puts both Node and web
  // code into one file. The node part uses Nodeâ€™s `fs` module to load the wasm
  // file.
  // Issue: https://github.com/kripken/emscripten/issues/6542.
  web.node = { fs: 'empty' }

  const node = base()
  node.externals = [nodeExternals()]
  node.output.filename = '[name].bundle.node.js'
  node.target = 'node'

  console.log(`web: ${JSON.stringify(web, null, 2)}`)
  console.log(`node: ${JSON.stringify(node, null, 2)}`)

  return [web, node]
}
