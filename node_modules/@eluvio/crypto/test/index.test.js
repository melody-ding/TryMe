/* global page */

import ElvCrypto from '../src/index'
import ScratchBuffer from '../src/ScratchBuffer'
import Utils from '../src/Utils'

import fs from 'fs'
import crypto from 'crypto'
import through from 'through2'
import { Stream } from 'stream'

let elvc = null
// const seedData = new Uint8Array([0xDE, 0xAD, 0xBE, 0xEF])
// const testData = new Uint8Array([0xDF, 0xAE, 0xBF, 0xEA])
const testData = Utils.randomBytes(565)

const kBk = Utils.hexToBytes(
  '04053011c4c54f95062547ef2d8abf17d96b10364ca6c7c084274332529e90e211c3b42190c2750cba50105ef31ed3cda2055a100afea93aec3048e8b4f8a5b1cfe96f8ab2f8911e1b3bf31121bb35adbe79a5228ac079be8f0fd3090e39d90074'
)
const kDataClear = Utils.hexToBytes(
  '7d983e19b2adbcd94b356d0b69586a30b8f186741a7f887dc1e17f416f88b2a5fc2e3be42590dcbf01a33604042f02792eb440ab0a46561726069eb5e2bf69799af40458e2ed88661202390c41cc309c209a5794f77d67dc8ffbe3cd17917f5dcc58db04554de636be58683d28cadbbf7665dddeb4d46e36d28584c108109f1c8dd831c50cb7399bc616563db6dfffe4a856defa2843240bba3a84c471e62727865a450fd42c6caa2b354c25491e2e7331b11215a85c80d5a08492c1891791f988aa4f7bfbe1ce376e2113e59d1dd9f89d8e61a6f8d6227cbbde045949ea0eae271d74f3090d7b9c2971de53821306314bb3a7ea959a3010a665c54d2159ec6a7d2fb793e066982f1cc5098e77d35c1837ef2805707db25904bc71356e1695a43ef19570119b22bb514cd5af6a0c5c0d02687fee486452d7bb63d0a3119fc65ae6c9fc2d19df497bc35332118f98cb52648a0977646565729fb6d7f7101e1011b72147f6a079b4fd9be2be5c4eaac801e4bf9f2230e16c7fdb6aebe6e6dd2762477cee27115f276752f1e4830bdb0cc4a50e8c1592955b810ac3232ad5680b6bb1ec48d6aafb2e1f33fa5942303eaffeb3705e9ae626770b1a466c1c545f7cc3646b239fe63182f212d65303b08b07955047f1ac04e0550da0958d0b11c79c75ac16bb8eb691286aa9d9785cd2f791cd4bfe04286195636fc3e7270cb99747d3fc7a61c5110a81bba235413aec6d561d4dbd412495aef8d463bce622889c3224b5d478e0e32600dbe6b08cedf4437e0beff51ea950'
)
// const kDataClearLen = 565
const kDataEnc = Utils.hexToBytes(
  '04f246e07cc016fc0b2eb90764eebf8c4cb9b589720980eaa14744d81df973b5343f9d7e99250f979b3e5438197669c1172d5db64c3d423998371f5a685018b4bc645a4ea4ff32a15832d3e3e77e09d175d0de26521dbb37aaec32bc0c7718ce0cdd4e41e1d5197aff0ef4dd02b115c20ea2a4beaf8c1fa6cf30da368c547e47066038cc390c765acb12de8ea3b4af2a03998eceb173cb9755e6e3ff43c9b9542483e1c50256247d9d522c62d468c3fcf413ac27a936fee57240350e6b9b41d50f76537fa8b99c0c7eee955786558424d3150d2b26174f49d87b9e82656e09e3f99d5ee7e91be0efb33cf9d6ab9ae04901474f4d89f07432e2aa9e6aec7e1119634ca9409fa86a443b3e4b0a01e366c3921c912a676c20e9ca6565c12357a68402f166639d07ec60ba3888f7e465f9392691237bc8b1df90ecac7e3eb6e3fbd5c4345b539d27d5734807c142dcfe8a1602fec967bda2f09b5b69358ee26a37bcf2c89912959b20936f34192a657bb91de8e42680eb1d4cb04273c29119a67da30615db7752cf7deeb7f614efe24ef9cb83bdcabe4dde5dc7fae201ee265ef1c211182a85210895619eefbc027b39184b0aed59f36c4c4e434bb045889da447d54ce6cb228b902a0da3da6d4330e398e110ae1f699699b37a883dbc9052bf7f8019a4cf66c153f8c962e1551100899f2ced7b33a6fe4877f8422bf95794a16b4ce0b55c789dc5c99bdbc99a9b8b711b7114c625305efc8489507f9172c12f25cb4272f21df14657c88d75a4e8d93ac8e11e71a2f3ff697a953be869e2594eaf850ac2ead846c5d250d5705cefb4806eab26a160cf5871b72e7b48a104e04fd76db64edd929db7d1c1379ce3a196fcbee410c3e3e49a8f87d093dc08350d49e01c8448a35db12201c39f2c1eabfff0963577e80dc296ef18567c3f3c5b99dd4c88078ddaac4202841125090cffea01117c9e12c290f9b136efb260ad8c65638fa1a0bd471ef25978b79f47da5374d2dc550c2b2652c63da71db2dad0a1d5b6acf67769ae41e16c8cb3003668f51db8c6451340d7b27fe51419a6230795fd864723178042a2858b8d21a0a31c0d2c1eaa98d6498c8e39fa7b13bb74a484c34554f2804712a1fb1e9fd1f97601ab0ec1e3290e449222bd71e26c85880eb312b3c62b295bc1967af4743dd6f3039531215199e2c24eacc108100a1f4d272703c4cc6b0e9594da5723d6c03f8bac276e5043a1cbcf27a07789d093d75b4e5b4bd0785a7f69832d7ae6086d5ba90d83f03ff35f05e2ee90869ef7505e5e001b2cc64193ee208472f1810c290ebea07a9c4d5f745de50b395afde14c9b3f843ad1fee2fd1989b388fefaa74dc92699248bf9545b02890ea9f5a7efe48e39d2986e38a3f6712bed17e45da5a2a9ba9a6819d33e610ad1839ae06798fbabcc45d7d2bbac0cb88a082c2e99b07f1f82c0e4b0ed014145a5323dacee86c3d9e6c7a66cf21f5b185d5cd7bce1e48e8d39f4574f20d098ac54391dc2efa1c3a9ecd13afa66a35d629faff6da58d2eb4e9f7a5049fc27df10c5f96030290f56b90ddefa2c2fbe607870c25c98e927718f9e9c5ef35582a97e30673e7132e50439ac628643de3609'
)
// const kDataEncLen = 1152
const kDataEncH = Utils.hexToBytes(
  '73faca9e3d2f5f037300f3c231db562b786c8c1fb2ef8e8128e07afe00000235040b19bfb494b50ac2ecebdeef0507cae6144cc52fb587f608489a083d77cfeec9ef8f7a9e73a00526b8e121fe67a093a90bbcc7ff29cea42e6ec2938c56c72bbc09aea4a45e4994c91df763d14c669e73cf769d73690b93775fd9a08fc076caab1274f82e473e8dafdded5420ad9fabb004496590b9acc9f72fc9cb161565a465590196025dc1696e55d3cc9b27f297f012fc951afbc9acca75873bea921d6f392d281100ee156a8c1c9384e3540cf290e0dced7bb47e3858cbdd082004e4ca6d0a093bf80a145b497f6b94096307bbd81fc7f3c3aad0f93de8a608063f89a597a44a8286a36947fb93bcb3a5274fe91a151ebf64320758af2b13d2fddbe01c8aef43630ea0f8f80187782070bb23b1726df9fe75789559c622f9abbaa0df855f14a64a61fdad8e8e6376cbece4609f67c709c23ca03292c81b15038a5ca8a8befa44126b50dbcd3c7371836c72b4e8850422f554b45f8cf03e10d928865faf1100aa1d724152c724d9847924e6ca55878a88ea09b79a18ea09940fe7499fb5a70a94c60ad3ab561236e2a219ab4b321bad0351eaf871cb3c316ce2e584c6d0f0bd83cc52ddd5caf3602ba822a7d0ea350dd63599abaaad87847c957da7de2ae2259509439ec9d5784437398adb56bc58621f222b5569a6e4b62054b6e0426cd9006a90e5ade025a69c4b7b1a24442606c8b3943522162c0cba8773a6dd7def190b2abd24d11e445e0652f21120513d7118e87e07b14676b23c19ffc61b5e2b6138d7662f2d0d76ef08e845a6bd1e136ebb177b41dc6810fe3cbbcaaa7da1a80d024be85b96b0afbda12109bca2f5bab3ba599568697b59a30db6acf88fe69eb7a6e0ddecc12f0842937b44f4f695dd990430ac38a8aec4423394396530ee6f3b8301d26917146e85ed7c78a5225bb263bf4057000b66b8a343400246c08dff9807203df273af327a7b8fe62dc37ea8fb75c6b17e6eda0fa7f4087b424c674ac67fb6e03d85ca2c68fd061951a36f29fc07c06154b721ab48237f784db1a35bd77dad9bc93ba3b01b249281e0884af330dea3803c211c4cce7bcb4ffc69b092511375d22c232636cd7acaab9880d9de32ed5645ea31c8ea2c6b5a99e7bf2d1310895b936ad9ef064c5f70b901c526095a0e33d48284e947bbb4ff686e043fa139f2bfa4017372de0110ba7adbc854a5c1fa9c056e6a88cf6c2c8b65fcd85ff13501dba6678fe58783b3c62dbeb01d64466105b7e5643cc5dc8a3a7f36955e89e11477cbcee7fa3650083d9495f63bab6d0000032414029684acce6c74e18028c5173b09b60005dead11676a6a2e8b73a3dc21b53e439f354d31ddf25da4fef44d021f3a52f854a2f1a4842f6135cb48a3fa6bc643911447c38a7f4e766c39154eab79691c822618091cd03aff7bd1b54000485ea2695b0152c97fbbaae87d09aca4137b17090105902fed6e845c85adcdf3ffcf5cad9839dd58a58e226ebb95df0b27ff851dafd051829c577ccfd3aad7d17cb5fed50eee85f65b07efdb12888ff77b634d71960b44c84b90705993335e04880303aa1425348e52b35f846bdfdf190d3e31b033bf0218e41d8053a088510c7bedfdc25fccf92a7c88a32d375f1f06a009c42f0ea07e9551b3465461d2bb9029f04ddb50a6acdd24e4f4f4b49b55179ddab64c93c434e8f67ffd8718fbef0c39559daf7888ea5dac94f2b2d48793ec1b09f9d01c2163de47be2a7b3d86983412a2c9934c6847b1d476433042ceb9'
)
// Note: reEncryptH generates different output each time it seems, but this should still match kDataClear when decrypted
const kDataReEncH = Utils.hexToBytes(
  '403d4a32dbdc6d030a2beecef5de1d942328beeb1663d4e50c2be6080000023505b9af2cee9f499aea1885f8a44fd7ec8e4414d5312b4313b06d801e1449e75eefaf06b14c1aa1e2b56dec22784116c308620e9e5272c4a44b814ed7b9a9288d74391fa608aa3061550a38c598d77d7fc17c3503a12873c1dfb00dc8d3cff8de023be9cbb7b9b30d6c7f27bb0c4f16896688ceec776ff638402609195a376f4db4d3d954ff16c03ecd73b19fb03d763e045da7ab5c948902a5a61837146f94b9c1009da655e1c4fbe51005341b910087b09ec005d6930ba8ddf0437dec0082f505fee82c9790e39eb40bd8f131f8ad3d04d9299450f95c6ecbca25cad205870aee7af2a8f0e0c8384a9f219b2539216608e454ae58e4bfaa5bfb3be563758ce563f238d961594f4541bee3deb0dd312207a439c318e9d4085fc34806645507010abfca028e642b6e8b7a003161b5001cc84d50a9f69f145de588fcb6e003a75d65a3b4d29627587b45b4c9e5752bd0b600c6eb6a869d83ed470c2ae20f564c8ca68322391ce76f078fa6cb00eddbbff81319d358f1e9583e00f6b0792f3ec253118b1a30b56c4aabe3feeb81b0ff8ca42a5bac332493bfbba910e09754fa61c95b0f331b7fb2297ad69100b41b4ea19213a8030c0b697318c98061aa8c6e94f27496c8dc17779a43e19d47801ecae00590c9d064416b866d277216e01fa5258c0deea316ab222093e8c0f08dc97bfe1d134061d866e5af279cd2faed9864b1ed3f1d39613bd00d12727c6bcd769571060aa801d66a98eb65b52c7aaedfb20d45654457c2ba6c3bf5bd387e650f337255debd030d7eef0dd0db133f544cdd89e414f7c78625552793de9759be7e6fbba90a870ac5e11be32c6364fe475a34fc1f3fcb1854f70bef41728a823b1ae5376206ab8dbd09e13c353d4081a8372046ac9389593fadbf800113e574d03fbc365fc4ccff7da0e72bf6113d5173a383fca0057208f7ff8226f10397d01ff9d291c07da1f862eea01e51cecbaff8d858ad5e23b64d86dfa3a8ae1189ad0189738b5c0c942b2e231d04046493b998dda43ed077ab813ce909e8225c7999df3db11344ee15006de25a75df102594f8a488edc8012893a9bb2cd1f88e8bab7f042a2567d4a3e0671e1468f964772d4fadf6ad8f9f9531b8971d5dbdb5a41fed945e02a517efb40387c090f693aef493008dff5aa0b2bdc15a35f709193986081a787863afa206390588bf910d5f0a85f6f4bdf510e4ac8d2a8f51f45ab7f01e3c0aad78819d19b8c56f51a11f67049a0d0718b226f7e37d9bd1a503579918c9b9d5b49113a6d25f9d1f6b2809fea539caaeba51898601f2b2b60b269b3bbc5ef2b0631e3626b6bedf3f0fb4203c56c726c969600478945fe281b002370b2679c1493c2b9d62b1d122dba4f7c01df2da4c4b9b7533e18921b3a4323cdcdc2a1991d39b09189fb5353139c24d9f41fc30f7a56c23871904e3d2c32d7b0f73e568fcfdf715eae3f45278b1fa2ce3a55d323e0aba180164781e8e53e134cf9e29ca5527ec7e06f8910971f5725382173666e0c89644ebd845207a0f1cc1bf84d115b077d3a00b0dc4f049d5bc97719cbf6766d998525da580fdd3030bf221f7953cdb74f95e2fa02c01a3e4715fb83e73d3cec340230479b361275a30a2ee650934555481bf2738f7711c2e9483560fee62b7910f28dd3262d4f42386b313fbe4d39275098a021be7ec3144acf70d07ca1025a810ea1c1acb91450ff2c267fc88c35597cc529a6ca5edf5608e392b264e63f07381c40eb394e29cf0a9dd58bdd40ac4d03d83ad4211345a97b9a2ff54de4b27b7a68675cc12076a5dddeae3a19223109106730cfbce47cfaa302246b81804e89a9b8a02607f3e0a00afc7709c1e689983b3ed687d1e4ed67ed2a622fe066b9a8f7d9d08396d515e4a59829d5382688dfcc391f12584d16fc944106415f4d83b72531f47c0c46544fa384fa881a9658e2d4fee0b6e1bb05740472504175c95cbdc588e60d7f35da2e1e4a691cf417cb79e1583e60a0f564fe9d269f2f4db84934c23b5134ae361b46c56daa0d0106d8b236469eb67ce46fdccf6be75dfa3e9eda629a86bad17ed7ab2f65d01278e75db9741a80e0a08422007d9a0773da37dec637323c4fa07a891253792f38b92a6ae234f6988b0daaec3432d00f84282800cc70f5905b42d18ad6368d3be48cc9ac3e7f5316f8c2a459f2d7e8ad818a43823d131191350b627730dd03d7479355ea9e867800523d9449d0b61f448f93a2169bf761ef51de1c74f4de054545542a42b4459ff1f948bfda9878a10c9d789726b98ac93151b283008934e874b71aaa1e167be05cb7d6254b66b57335900c602ecbf61af6c4b9962b67ac90fa23a9b632f271c770f470c27a77b1ac989ca72d385d6f38dc8ab7d51ca0a9e6781e98494f38024bfa4e6b4b4d6c091d918b89f6841c6f9e4'
)

const kIv = Utils.hexToBytes('73faca9e3d2f5f037300f3c2')
const kPrimPk = Utils.hexToBytes(
  '040dd81022749b62177066b52a41fd20698d25e700216f733dd0c837ee2851165033bd50553315b9d9210046bf0d77427011095220447d74d9a674b49e244d9b9524d4dd399ff7ed612e7316c60f715e448fb8bad36308ea7a74186e78ac99cf6d'
)
const kPrimSk = Utils.hexToBytes(
  '000000000000000000000000000000006e8d11f8a3b061e3390df396c75fed34bd8295df895f7e3db1d7778e80fe0576'
)
const kRk = Utils.hexToBytes(
  '0411a9e5b3d1ba865df32f2975ad484b81569eedc2a9eaf0cb3862ba190f00740865a62d423a67b7052c1c2b7c8a634fe20294b2755000ff77f0239cf677ad04da0dde09b093f5ff69f56d7c4a2759e962c359a406ae8767b910562e5eb40f88cb0494367a622a1f3d7f7aba3944844c0580aba50eb1214a8b86028e25ff983f30695bd9b53d238b2a7beec13df161ae88180bd0a75ccb4247c8eed3e2b9d5a474b3f04ce276a53d41d6459582af830aa24ac3fb190983d8bb2ed8ecd33c2e54e3'
)
const kSym = Utils.hexToBytes('0acda15fb4853101cb2b987ec681bf01')
const kTag = Utils.hexToBytes('31db562b786c8c1fb2ef8e8128e07afe')
const kTargetBk = Utils.hexToBytes(
  '1878653e5d394c7dc045109b7028fbb3a4b397077cf359e3c05afa26e53265917ec557f6c018f89fbea1d79431f7e2fa0a531f648e8028918b654fe42aec63c2baf1d4cf6a53e22061a7d2ad4e5659afe9fa0fb06dd4d51260b440bea1b9a28712d4dd075d2afb587399ae3d2d8fca017452bea1af760bd6ef55c55696e9e1a9125ec72020840963c8f52f8d0c89b8030f84253fd6f8ff571cd58e1b568813ee7a3730db0e5430cefdfc6140431036e21f6496b67bfba17caf22e9156c3a50171073645c67dd7d96e8679c5c59e56d96717bd96f5c5864ed980a79bbb4130236f3b09e29354c1faa42bb7ac70da1a99307244fa1e09f689c3c89deae645a29cff46ada6b8dfad72876297ecdce0c8a89dc95dfe0c8e5128a4f73ff27cea7dc8b1058109595ed0d845bec6ed878361f0e9db7eda4eefd40f4ff41cba9d2e1eabfe27b3779af8fc8f6893d49d26c92fe7d02b9cdfda7082942d500fa654da4ea87c3eb68cabb77689928af9449039430549051f600ddf88c12751bf89d8519299c166815bb6898292c699b999375949d7fd50912459c3bb3f0dd6edb58928e631c8b873b11b961039a014306247805e73706137b015b03264c432034e734cca439e416970ee16fb5c6ed610cae2eb1c5e3eaa3ce06abb977f4bc121bae3eb984740d77df136efecc95b4f478c70f9ed0b91382bf4d99ba249ef3c0b95494b4053c988d322a9d6165f91048f4a93d15275e1890fd13119861e23eed4569afab2e5705053a35b38adb3fd8925f6b954e7029ba985442bc75ca6b0e1c69c9145c47da'
)
const kTargetPk = Utils.hexToBytes(
  '0410e0f01eb512cb0a4b8aadec8d4b773d065d4e5c403ac6561aa003e6d47fe3912199fd16232abbd0cbb53a71e1fc62fa00e3c39138af21358fd5e7d3f8a56c20b951c10537d804bb3fdcb7fb7f06a9ba60b877465dd754f26d8e2dd852aa63b30c45d215aa3f1a1da234a8590655cfe985cdaf28168ab57c3511a7aeb95fdc9344bd78aacbf238de30ca1f8da6fe8f7718077425756d1717e10253b3dca7f03c6809ece5c3986549eecd7ad381c2da33cf8131b8be91b2adfb7033b03da1e935'
)
const kTargetSk = Utils.hexToBytes(
  '000000000000000000000000000000000495e7c04f69dcf2278193fddcf7be0f496ea27141693a86118899361c1b0c56'
)

const kTestFileSize = 1000 * 1000

function createTestFile(path) {
  const increment = 1000 * 100
  let bytes = 0
  while (bytes < kTestFileSize) {
    const data = crypto.randomBytes(increment)
    bytes += data.length
    fs.appendFileSync(path, data)
  }
}

// TODO
function createTestStream(path) {
  const increment = 1000 * 100
  const stream = fs.createWriteStream(path).on('error', e => {
    throw e
  })

  let bytes = 0
  write()

  function write() {
    let ok = true
    while (bytes < kTestFileSize && ok) {
      const data = crypto.randomBytes(increment)
      bytes += data.length
      ok = stream.write(data)
    }
    if (bytes < kTestFileSize) {
      stream.once('drain', write)
    } else if (bytes == kTestFileSize) {
      stream.end()
    } else {
      throw new Error(
        '' + bytes + ' bytes written but expected ' + kTestFileSize
      )
    }
  }
}

let genFilePathCount = 0

function genFilePath() {
  return process.cwd() + '/' + genFilePathCount++ + '.tmp'
}

beforeAll(() => {
  return new ElvCrypto().init().then(instance => {
    elvc = instance
  })
})

test('puppeteer can browse google.com', async () => {
  await page.goto('https://google.com')
  await expect(page).toMatch('google')
})

test('random data generator', async () => {
  const seed = await page.evaluate(() => {
    let seed = new Uint8Array(96)
    window.crypto.getRandomValues(seed)
    return seed.reduce(
      (str, byte) => str + byte.toString(16).padStart(2, '0'),
      ''
    )
  })
  expect(seed.length).toBe(96 * 2)
  expect(Utils.randomBytes(96).length).toBe(96)
})

test('module initialized', () => {
  expect(elvc).not.toBeNull()
})

test('generate symmetric keys', () => {
  const k = elvc.generateSymmetricKey()
  expect(k).not.toBeNull()
  expect(k.key).toBeDefined()
  expect(k.key.length).toBe(16)
  expect(typeof k.key[0]).toBe('number')
  expect(k.iv).toBeDefined()
  expect(k.iv.length).toBe(12)
  expect(typeof k.iv[0]).toBe('number')
})

test('generate primary keys', () => {
  const k = elvc.generatePrimaryKeys()
  expect(k).not.toBeNull()
  expect(k.secretKey).toBeDefined()
  expect(k.secretKey.length).toBe(48)
  expect(typeof k.secretKey[0]).toBe('number')
  expect(k.publicKey).toBeDefined()
  expect(k.publicKey.length).toBe(97)
  expect(typeof k.publicKey[0]).toBe('number')
})

test('generate target keys', () => {
  const k = elvc.generateTargetKeys()
  expect(k).not.toBeNull()
  expect(k.secretKey).toBeDefined()
  expect(k.secretKey.length).toBe(48)
  expect(typeof k.secretKey[0]).toBe('number')
  expect(k.publicKey).toBeDefined()
  expect(k.publicKey.length).toBe(193)
  expect(typeof k.publicKey[0]).toBe('number')
})

test('generate re-encryption key', () => {
  const generatedRk = elvc.generateReEncryptionKey(kPrimSk, kTargetPk)
  expect(generatedRk).not.toBeNull()
  expect(generatedRk.join()).toEqual(kRk.join())
})

test('iv generation', () => {
  expect(elvc.IV_SIZE).toBe(12)

  // Returns { secretKey, publicKey }
  const primaryKeys = elvc.generatePrimaryKeys()
  // Returns { key, iv }
  const symmetricKey = elvc.generateSymmetricKey()
  const context = elvc.newPrimaryContext(
    primaryKeys.publicKey,
    null,
    symmetricKey.key
  )

  const a = context.generateNextBlockIV()
  const b = context.generateNextBlockIV()
  expect(a.join()).not.toEqual(b.join())

  context.nextBlockIV = new Uint8Array([
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255
  ])
  context.generateNextBlockIV()
  expect(context.nextBlockIV.join()).toEqual('0,0,0,0,0,0,0,0,0,0,0,0')

  context.free()
})

test('calculate encryption output size', () => {
  const len = elvc.calcEncByteCount(17)
  expect(len).toBe(576)
})

test('calculate ECIES encryption output size', () => {
  const len = elvc.calcEncECIESByteCount(17)
  expect(len).toBe(32)
})

test('encrypt and decrypt using ECIES', () => {
  const skBytes = Utils.hexToBytes(
    'e00b1421c952f9dfc20c297eb38caf621620ce2e0538fa26f9a5d514f52e9408'
  )
  const pkBytes = Utils.hexToBytes(
    '045810acf4f900f4144276a40d977ed547fc7847b0c72b8fb48d55469c329c476347017f6ecf4b23768f0a5925141e12561b3713ca5976d24c3ede6b8bb329b8c2'
  )
  const encLen = elvc.calcEncECIESByteCount(testData.length)

  const enc = elvc.encryptECIES(testData, pkBytes)
  expect(enc.data).toBeDefined()
  expect(enc.data.length).toBe(encLen)
  expect(typeof enc.data[0]).toBe('number')
  expect(enc.ephemeralKey).toBeDefined()
  expect(enc.ephemeralKey.length).toBe(65)
  expect(typeof enc.ephemeralKey[0]).toBe('number')
  expect(enc.tag).toBeDefined()
  expect(enc.tag.length).toBe(16)
  expect(typeof enc.tag[0]).toBe('number')

  const dec = elvc.decryptECIES(enc.data, skBytes, enc.ephemeralKey, enc.tag)
  expect(dec).not.toBeNull()
  expect(typeof dec[0]).toBe('number')
  expect(dec.join()).toEqual(testData.join())
})

test('primary decryption', () => {
  const context = elvc.newPrimaryContext(kPrimPk, kPrimSk, kSym)
  const dec = elvc.decryptPrimary(
    context,
    kDataEnc,
    kTag,
    kBk,
    kIv,
    kDataClear.length
  )
  expect(dec).not.toBeNull()
  expect(typeof dec[0]).toBe('number')
  expect(dec.join()).toEqual(kDataClear.join())
  context.free()
})

test('test ArrayBuffer parameter', () => {
  const context = elvc.newPrimaryContext(kPrimPk, kPrimSk, kSym)
  const dec = elvc.decryptPrimary(
    context,
    kDataEnc.buffer,
    kTag,
    kBk,
    kIv,
    kDataClear.length
  )
  expect(dec).not.toBeNull()
  expect(typeof dec[0]).toBe('number')
  expect(dec.join()).toEqual(kDataClear.join())
  context.free()
})

test('primary encryption and decryption', () => {
  const context = elvc.newPrimaryContext(kPrimPk, kPrimSk, kSym)
  const enc = elvc.encryptPrimary(context, kDataClear, kIv)
  expect(enc.tag.join()).toEqual(kTag.join())
  expect(enc.blockKey).toBeDefined()
  expect(enc.blockKey.length).toBe(97)
  expect(typeof enc.blockKey[0]).toBe('number')
  expect(enc.data).toBeDefined()
  expect(enc.data.length).toBe(kDataEnc.length)
  expect(typeof enc.data[0]).toBe('number')

  context.clearBuf()
  const dec = elvc.decryptPrimary(
    context,
    enc.data,
    enc.tag,
    enc.blockKey,
    kIv,
    kDataClear.length
  )
  expect(dec).not.toBeNull()
  expect(typeof dec[0]).toBe('number')
  expect(dec.join()).toEqual(kDataClear.join())
  context.free()
})

test('target decryption', () => {
  const context = elvc.newTargetDecryptionContext(kTargetSk, kSym)
  const dec = elvc.decryptTarget(
    context,
    kDataEnc,
    kTag,
    kTargetBk,
    kIv,
    kDataClear.length
  )
  expect(dec).not.toBeNull()
  expect(typeof dec[0]).toBe('number')
  expect(dec.join()).toEqual(kDataClear.join())
  context.free()
})

test('proxy re-encryption', () => {
  const pontext = elvc.newPrimaryContext(kPrimPk, kPrimSk, kSym)
  const enc = elvc.encryptPrimary(pontext, kDataClear, kIv)
  expect(enc.tag.join()).toEqual(kTag.join())
  expect(enc.blockKey.length).toBe(97)
  expect(typeof enc.blockKey[0]).toBe('number')
  expect(enc.data.length).toBe(kDataEnc.length)
  expect(typeof enc.data[0]).toBe('number')

  const pdontext = elvc.newPrimaryContext(kPrimPk, kPrimSk, kSym)
  const pdec = elvc.decryptPrimary(
    pdontext,
    enc.data,
    enc.tag,
    enc.blockKey,
    kIv,
    kDataClear.length
  )
  expect(pdec.join()).toEqual(kDataClear.join())

  const rk = elvc.generateReEncryptionKey(kPrimSk, kTargetPk)
  expect(rk.join()).toEqual(kRk.join())
  const targetBk = elvc.reEncryptBlockKey(rk, enc.blockKey)
  const tontext = elvc.newTargetDecryptionContext(kTargetSk, kSym)
  const tdec = elvc.decryptTarget(
    tontext,
    enc.data,
    enc.tag,
    targetBk,
    kIv,
    kDataClear.length
  )
  expect(tdec.join()).toEqual(kDataClear.join())

  tontext.free()
  pontext.free()
})

test('full primary encryption and decryption', () => {
  // Returns { secretKey, publicKey }
  const primaryKeys = elvc.generatePrimaryKeys()
  // Returns { key, iv }
  const symmetricKey = elvc.generateSymmetricKey()
  const context = elvc.newPrimaryContext(
    primaryKeys.publicKey,
    primaryKeys.secretKey,
    symmetricKey.key
  )

  const iv = context.generateNextBlockIV()
  // Returns { tag, blockKey, data }
  const enc = elvc.encryptPrimary(context, testData, iv)
  expect(enc.tag).toBeDefined()
  expect(enc.tag.length).toBe(16)
  expect(typeof enc.tag[0]).toBe('number')
  expect(enc.blockKey).toBeDefined()
  expect(enc.blockKey.length).toBe(97)
  expect(typeof enc.blockKey[0]).toBe('number')
  expect(enc.data).toBeDefined()
  expect(enc.data.length).toBe(elvc.calcEncByteCount(testData.length))
  expect(typeof enc.data[0]).toBe('number')

  context.clearBuf()
  const decData = elvc.decryptPrimary(
    context,
    enc.data,
    enc.tag,
    enc.blockKey,
    iv,
    testData.length
  )
  expect(decData).not.toBeNull()
  expect(typeof decData[0]).toBe('number')
  expect(decData.join()).toEqual(testData.join())
  context.free()
})

test('primary encryption and decryption with headers', () => {
  // Returns { secretKey, publicKey }
  const primaryKeys = elvc.generatePrimaryKeys()
  // Returns { key, iv }
  const symmetricKey = elvc.generateSymmetricKey()
  const context = elvc.newPrimaryContext(
    primaryKeys.publicKey,
    primaryKeys.secretKey,
    symmetricKey.key
  )

  const encData = elvc.encryptPrimaryH(context, testData)
  expect(encData).not.toBeNull()
  expect(encData.length).toBe(
    elvc.calcEncByteCountH(elvc.CRYPTO_TYPE_PRIMARY, testData.length)
  )
  expect(typeof encData[0]).toBe('number')

  context.clearBuf()
  const decData = elvc.decryptH(elvc.CRYPTO_TYPE_PRIMARY, context, encData)
  expect(decData).not.toBeNull()
  expect(typeof decData[0]).toBe('number')
  expect(decData.join()).toEqual(testData.join())
  context.free()
})

test('proxy re-encryption with headers', () => {
  const context = elvc.newPrimaryContext(kPrimPk, kPrimSk, kSym)
  const enc = elvc.encryptPrimaryH(context, testData, kIv)
  expect(enc.length).toBe(
    elvc.calcEncByteCountH(elvc.CRYPTO_TYPE_PRIMARY, testData.length)
  )

  const scratch = new ScratchBuffer(elvc.wasm)
  const re = elvc.reEncryptH(scratch, kRk, enc)

  const tontext = elvc.newTargetDecryptionContext(kTargetSk, kSym)
  const dec = elvc.decryptH(elvc.CRYPTO_TYPE_TARGET, tontext, re)
  expect(dec.join()).toEqual(testData.join())
  scratch.free()
  tontext.free()
  context.free()
})

test('full proxy re-encryption', () => {
  // Returns { secretKey, publicKey }
  const primaryKeys = elvc.generatePrimaryKeys()
  // Returns { key, iv }
  const symmetricKey = elvc.generateSymmetricKey()
  const primaryContext = elvc.newPrimaryContext(
    primaryKeys.publicKey,
    null,
    symmetricKey.key
  )

  const iv = primaryContext.generateNextBlockIV()
  // Returns { tag, blockKey, data }
  const primaryEnc = elvc.encryptPrimary(primaryContext, testData, iv)

  // Returns { secretKey, publicKey }
  const targetKeys = elvc.generateTargetKeys()
  const reEncKey = elvc.generateReEncryptionKey(
    primaryKeys.secretKey,
    targetKeys.publicKey
  )
  const reEncBlockKey = elvc.reEncryptBlockKey(reEncKey, primaryEnc.blockKey)
  const targetContext = elvc.newTargetDecryptionContext(
    targetKeys.secretKey,
    symmetricKey.key
  )
  const decData = elvc.decryptTarget(
    targetContext,
    primaryEnc.data,
    primaryEnc.tag,
    reEncBlockKey,
    iv,
    testData.length
  )
  expect(typeof decData[0]).toBe('number')
  expect(decData.join()).toEqual(testData.join())

  targetContext.free()
  primaryContext.free()
})

test('primary stream encryption and decryption', done => {
  let inFile = genFilePath()
  let outFile = genFilePath()
  createTestFile(inFile)
  const context = elvc.newPrimaryContext(kPrimPk, kPrimSk, kSym)
  const dontext = elvc.newPrimaryContext(kPrimPk, kPrimSk, kSym)
  const cipher = elvc.createCipher(context)
  const decipher = elvc.createDecipher(elvc.CRYPTO_TYPE_PRIMARY, dontext)
  const input = fs.createReadStream(inFile)
  let output = fs.createWriteStream(outFile)
  let inHash = crypto.createHash('sha256')
  let outHash = crypto.createHash('sha256')
  input
    .pipe(
      through(function(chunk, enc, callback) {
        inHash.update(chunk)
        this.push(chunk)
        callback()
      })
    )
    .pipe(cipher)
    .pipe(decipher)
    .pipe(
      through(function(chunk, enc, callback) {
        outHash.update(chunk)
        this.push(chunk)
        callback()
      })
    )
    .pipe(output)
  input
    .on('end', () => {
      expect(input.bytesRead).toEqual(kTestFileSize)
      expect(fs.statSync(inFile).size).toEqual(kTestFileSize)
    })
    .on('error', e => {
      done.fail(e)
    })
  output
    .on('finish', () => {
      dontext.free()
      context.free()
      expect(fs.statSync(outFile).size).toEqual(kTestFileSize)
      expect(inHash.digest()).toEqual(outHash.digest())
      done()
    })
    .on('error', e => {
      done.fail(e)
    })
})

test('primary stream decryption of chunks containing partial blocks', done => {
  const context = elvc.newPrimaryContext(kPrimPk, kPrimSk, kSym)
  const decipher = elvc.createDecipher(elvc.CRYPTO_TYPE_PRIMARY, context)
  const input = new Stream.PassThrough()
  input.end(Buffer.from(kDataEncH))
  var chunks = []
  input
    .pipe(
      through(function(chunk, enc, callback) {
        /*
         * Test decipher handling partial blocks
         */
        let index = 0
        while (true) {
          let slice = chunk.slice(index, index + 100)
          this.push(slice)
          index += slice.length
          if (index >= chunk.length) {
            break
          }
        }
        callback()
      })
    )
    .pipe(decipher)
    .on('data', chunk => {
      chunks.push(chunk)
    })
    .on('finish', () => {
      context.free()
      expect(chunks.length).not.toBe(0)
      expect(Buffer.concat(chunks).join()).toEqual(kDataClear.join())
      done()
    })
    .on('error', e => {
      done.fail(e)
    })
})

test('primary stream decryption of chunks containing multiple blocks', done => {
  const context = elvc.newPrimaryContext(kPrimPk, kPrimSk, kSym)
  const decipher = elvc.createDecipher(elvc.CRYPTO_TYPE_PRIMARY, context)
  const input = new Stream.PassThrough()
  input.end(Buffer.concat([kDataEncH, kDataEncH]))
  var chunks = []
  input
    .pipe(decipher)
    .on('data', chunk => {
      chunks.push(chunk)
    })
    .on('finish', () => {
      context.free()
      expect(chunks.length).not.toBe(0)
      expect(Buffer.concat(chunks).join()).toEqual(
        Buffer.concat([kDataClear, kDataClear]).join()
      )
      done()
    })
    .on('error', e => {
      done.fail(e)
    })
})

test('target stream encryption and decryption', done => {
  let inFile = genFilePath()
  let outFile = genFilePath()
  createTestFile(inFile)
  const pontext = elvc.newPrimaryContext(kPrimPk, kPrimSk, kSym)
  const cipher = elvc.createCipher(pontext)
  const recipher = elvc.createRecipher(kRk)
  const tontext = elvc.newTargetDecryptionContext(kTargetSk, kSym)
  const decipher = elvc.createDecipher(elvc.CRYPTO_TYPE_TARGET, tontext)
  const input = fs.createReadStream(inFile)
  let output = fs.createWriteStream(outFile)
  let inHash = crypto.createHash('sha256')
  let outHash = crypto.createHash('sha256')
  input
    .pipe(
      through(function(chunk, enc, callback) {
        inHash.update(chunk)
        this.push(chunk)
        callback()
      })
    )
    .pipe(cipher)
    .pipe(recipher)
    .pipe(decipher)
    .pipe(
      through(function(chunk, enc, callback) {
        outHash.update(chunk)
        this.push(chunk)
        callback()
      })
    )
    .pipe(output)
  input
    .on('end', () => {
      expect(input.bytesRead).toEqual(kTestFileSize)
      expect(fs.statSync(inFile).size).toEqual(kTestFileSize)
    })
    .on('error', e => {
      done.fail(e)
    })
  output
    .on('finish', () => {
      expect(fs.statSync(outFile).size).toEqual(kTestFileSize)
      expect(inHash.digest()).toEqual(outHash.digest())
      pontext.free()
      tontext.free()
      done()
    })
    .on('error', e => {
      done.fail(e)
    })
})

test('target stream decryption', done => {
  const tontext = elvc.newTargetDecryptionContext(kTargetSk, kSym)
  const decipher = elvc.createDecipher(elvc.CRYPTO_TYPE_TARGET, tontext)
  const input = new Stream.PassThrough()
  input.end(kDataReEncH)
  var chunks = []
  input
    .pipe(decipher)
    .on('data', chunk => {
      chunks.push(chunk)
    })
    .on('finish', () => {
      expect(chunks.length).not.toEqual(0)
      expect(Buffer.concat(chunks).join()).toEqual(kDataClear.join())
      tontext.free()
      done()
    })
    .on('error', e => {
      done.fail(e)
    })
})

test('target stream decryption of chunks containing partial blocks', done => {
  let inFile = genFilePath()
  let outFile = genFilePath()
  createTestFile(inFile)
  const pontext = elvc.newPrimaryContext(kPrimPk, kPrimSk, kSym)
  const cipher = elvc.createCipher(pontext)
  const recipher = elvc.createRecipher(kRk)
  const tontext = elvc.newTargetDecryptionContext(kTargetSk, kSym)
  const decipher = elvc.createDecipher(elvc.CRYPTO_TYPE_TARGET, tontext)
  const input = fs.createReadStream(inFile)
  let output = fs.createWriteStream(outFile)
  let inHash = crypto.createHash('sha256')
  let outHash = crypto.createHash('sha256')
  input
    .pipe(
      through(function(chunk, enc, callback) {
        inHash.update(chunk)
        this.push(chunk)
        callback()
      })
    )
    .pipe(cipher)
    .pipe(
      through(function(chunk, enc, callback) {
        /*
         * Test decipher handling partial blocks
         */
        let index = 0
        while (true) {
          let slice = chunk.slice(index, index + 10000)
          this.push(slice)
          index += slice.length
          if (index >= chunk.length) {
            break
          }
        }
        callback()
      })
    )
    .pipe(recipher)
    .pipe(decipher)
    .pipe(
      through(function(chunk, enc, callback) {
        outHash.update(chunk)
        this.push(chunk)
        callback()
      })
    )
    .pipe(output)
  input
    .on('end', () => {
      expect(input.bytesRead).toEqual(kTestFileSize)
      expect(fs.statSync(inFile).size).toEqual(kTestFileSize)
    })
    .on('error', e => {
      done.fail(e)
    })
  output
    .on('finish', () => {
      pontext.free()
      tontext.free()
      expect(fs.statSync(outFile).size).toEqual(kTestFileSize)
      expect(inHash.digest()).toEqual(outHash.digest())
      done()
    })
    .on('error', e => {
      done.fail(e)
    })
})

test('target stream decryption of chunks containing multiple blocks', done => {
  const recipher = elvc.createRecipher(kRk)
  const tontext = elvc.newTargetDecryptionContext(kTargetSk, kSym)
  const decipher = elvc.createDecipher(elvc.CRYPTO_TYPE_TARGET, tontext)
  const input = new Stream.PassThrough()
  input.end(Buffer.concat([kDataEncH, kDataEncH]))
  var chunks = []
  input
    .pipe(recipher)
    .pipe(decipher)
    .on('data', chunk => {
      chunks.push(chunk)
    })
    .on('finish', () => {
      expect(chunks.length).not.toEqual(0)
      expect(Buffer.concat(chunks).join()).toEqual(
        Buffer.concat([kDataClear, kDataClear]).join()
      )
      tontext.free()
      done()
    })
    .on('error', e => {
      done.fail(e)
    })
})

test('primary stream decryption with a bad key', done => {
  const badKey = Utils.hexToBytes(
    '000000000000000000000000000000006e8d11f8a3b061e3390df396c75fed34bd8295df895f7e3db1d7778e80fe0577'
  )
  const context = elvc.newPrimaryContext('', badKey, kSym)
  const decipher = elvc.createDecipher(elvc.CRYPTO_TYPE_PRIMARY, context)
  const input = new Stream.PassThrough()
  input.end(kDataEncH)
  let chunks = []
  input
    .pipe(decipher)
    .on('data', chunk => {
      chunks.push(chunk)
    })
    .on('finish', () => {
      done.fail(new Error('Error expected'))
    })
    .on('error', e => {
      expect(chunks.length).toEqual(0)
      expect(e.message).toEqual('_DecryptH failed with error code -1')
      context.free()
      done()
    })
})

test('target stream decryption with a bad key', done => {
  const badKey = Utils.hexToBytes(
    '000000000000000000000000000000000495e7c04f69dcf2278193fddcf7be0f496ea27141693a86118899361c1b0c57'
  )
  const recipher = elvc.createRecipher(kRk)
  const tontext = elvc.newTargetDecryptionContext(badKey, kSym)
  const decipher = elvc.createDecipher(elvc.CRYPTO_TYPE_TARGET, tontext)
  const input = new Stream.PassThrough()
  input.end(kDataEncH)
  var chunks = []
  input
    .pipe(recipher)
    .pipe(decipher)
    .on('data', chunk => {
      chunks.push(chunk)
    })
    .on('finish', () => {
      done.fail(new Error('Error expected'))
    })
    .on('error', e => {
      expect(chunks.length).toEqual(0)
      expect(e.message).toEqual('_DecryptH failed with error code -1')
      tontext.free()
      done()
    })
})

test('target stream decryption with bad data', done => {
  const tontext = elvc.newTargetDecryptionContext(kTargetSk, kSym)
  const decipher = elvc.createDecipher(elvc.CRYPTO_TYPE_TARGET, tontext)
  const input = new Stream.PassThrough()
  const badDataReEncH = Utils.hexToBytes(
    '03d4a32dbdc6d030a2beecef5de1d942328beeb1663d4e50c2be6080000023505b9af2cee9f499aea1885f8a44fd7ec8e4414d5312b4313b06d801e1449e75eefaf06b14c1aa1e2b56dec22784116c308620e9e5272c4a44b814ed7b9a9288d74391fa608aa3061550a38c598d77d7fc17c3503a12873c1dfb00dc8d3cff8de023be9cbb7b9b30d6c7f27bb0c4f16896688ceec776ff638402609195a376f4db4d3d954ff16c03ecd73b19fb03d763e045da7ab5c948902a5a61837146f94b9c1009da655e1c4fbe51005341b910087b09ec005d6930ba8ddf0437dec0082f505fee82c9790e39eb40bd8f131f8ad3d04d9299450f95c6ecbca25cad205870aee7af2a8f0e0c8384a9f219b2539216608e454ae58e4bfaa5bfb3be563758ce563f238d961594f4541bee3deb0dd312207a439c318e9d4085fc34806645507010abfca028e642b6e8b7a003161b5001cc84d50a9f69f145de588fcb6e003a75d65a3b4d29627587b45b4c9e5752bd0b600c6eb6a869d83ed470c2ae20f564c8ca68322391ce76f078fa6cb00eddbbff81319d358f1e9583e00f6b0792f3ec253118b1a30b56c4aabe3feeb81b0ff8ca42a5bac332493bfbba910e09754fa61c95b0f331b7fb2297ad69100b41b4ea19213a8030c0b697318c98061aa8c6e94f27496c8dc17779a43e19d47801ecae00590c9d064416b866d277216e01fa5258c0deea316ab222093e8c0f08dc97bfe1d134061d866e5af279cd2faed9864b1ed3f1d39613bd00d12727c6bcd769571060aa801d66a98eb65b52c7aaedfb20d45654457c2ba6c3bf5bd387e650f337255debd030d7eef0dd0db133f544cdd89e414f7c78625552793de9759be7e6fbba90a870ac5e11be32c6364fe475a34fc1f3fcb1854f70bef41728a823b1ae5376206ab8dbd09e13c353d4081a8372046ac9389593fadbf800113e574d03fbc365fc4ccff7da0e72bf6113d5173a383fca0057208f7ff8226f10397d01ff9d291c07da1f862eea01e51cecbaff8d858ad5e23b64d86dfa3a8ae1189ad0189738b5c0c942b2e231d04046493b998dda43ed077ab813ce909e8225c7999df3db11344ee15006de25a75df102594f8a488edc8012893a9bb2cd1f88e8bab7f042a2567d4a3e0671e1468f964772d4fadf6ad8f9f9531b8971d5dbdb5a41fed945e02a517efb40387c090f693aef493008dff5aa0b2bdc15a35f709193986081a787863afa206390588bf910d5f0a85f6f4bdf510e4ac8d2a8f51f45ab7f01e3c0aad78819d19b8c56f51a11f67049a0d0718b226f7e37d9bd1a503579918c9b9d5b49113a6d25f9d1f6b2809fea539caaeba51898601f2b2b60b269b3bbc5ef2b0631e3626b6bedf3f0fb4203c56c726c969600478945fe281b002370b2679c1493c2b9d62b1d122dba4f7c01df2da4c4b9b7533e18921b3a4323cdcdc2a1991d39b09189fb5353139c24d9f41fc30f7a56c23871904e3d2c32d7b0f73e568fcfdf715eae3f45278b1fa2ce3a55d323e0aba180164781e8e53e134cf9e29ca5527ec7e06f8910971f5725382173666e0c89644ebd845207a0f1cc1bf84d115b077d3a00b0dc4f049d5bc97719cbf6766d998525da580fdd3030bf221f7953cdb74f95e2fa02c01a3e4715fb83e73d3cec340230479b361275a30a2ee650934555481bf2738f7711c2e9483560fee62b7910f28dd3262d4f42386b313fbe4d39275098a021be7ec3144acf70d07ca1025a810ea1c1acb91450ff2c267fc88c35597cc529a6ca5edf5608e392b264e63f07381c40eb394e29cf0a9dd58bdd40ac4d03d83ad4211345a97b9a2ff54de4b27b7a68675cc12076a5dddeae3a19223109106730cfbce47cfaa302246b81804e89a9b8a02607f3e0a00afc7709c1e689983b3ed687d1e4ed67ed2a622fe066b9a8f7d9d08396d515e4a59829d5382688dfcc391f12584d16fc944106415f4d83b72531f47c0c46544fa384fa881a9658e2d4fee0b6e1bb05740472504175c95cbdc588e60d7f35da2e1e4a691cf417cb79e1583e60a0f564fe9d269f2f4db84934c23b5134ae361b46c56daa0d0106d8b236469eb67ce46fdccf6be75dfa3e9eda629a86bad17ed7ab2f65d01278e75db9741a80e0a08422007d9a0773da37dec637323c4fa07a891253792f38b92a6ae234f6988b0daaec3432d00f84282800cc70f5905b42d18ad6368d3be48cc9ac3e7f5316f8c2a459f2d7e8ad818a43823d131191350b627730dd03d7479355ea9e867800523d9449d0b61f448f93a2169bf761ef51de1c74f4de054545542a42b4459ff1f948bfda9878a10c9d789726b98ac93151b283008934e874b71aaa1e167be05cb7d6254b66b57335900c602ecbf61af6c4b9962b67ac90fa23a9b632f271c770f470c27a77b1ac989ca72d385d6f38dc8ab7d51ca0a9e6781e98494f38024bfa4e6b4b4d6c091d918b89f6841c6f9e4'
  )
  input.end(badDataReEncH)
  var chunks = []
  input
    .pipe(decipher)
    .on('data', chunk => {
      chunks.push(chunk)
    })
    .on('finish', () => {
      // called second (we may only find out on 'finish' that the data is bad,
      //   vs. just a partial block that we are waiting for the rest of)
      expect(chunks.length).toEqual(0)
    })
    .on('error', e => {
      // called first
      expect(e.message).toBeDefined()
      tontext.free()
      done()
    })
})
